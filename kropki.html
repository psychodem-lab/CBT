<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoÅ‚Ä…cz Kropki - Losowe Wyzwanie</title>
    <style>
        /* CSS: Ustawienia dla responsywnoÅ›ci i wyglÄ…du */
        :root {
            --color-primary: #007bff; 
            --color-success: #28a745; 
            --color-default: #6c757d; 
            --color-error: #dc3545;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 20px 10px;
            padding: 0;
            text-align: center;
        }

        h1 {
            color: #333;
        }

        /* Sekcja Statystyk */
        #stats {
            display: flex;
            justify-content: space-around;
            width: 90vw;
            max-width: 600px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 8px;
        }

        .stat-item {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
        }

        .stat-value {
            color: var(--color-primary);
        }

        /* Ustawienie pÅ‚Ã³tna jako responsywnego */
        canvas {
            max-width: 600px; 
            max-height: 400px;
            width: 90vw; 
            height: 60vw; 
            border: 2px solid var(--color-primary);
            background-color: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            touch-action: manipulation;
        }

        #info {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1.1em;
            color: #333;
            font-weight: bold;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        #resetButton {
            margin-top: 10px;
            padding: 10px 20px;
            background-color: var(--color-primary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s;
        }

        #resetButton:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <h1>PoÅ‚Ä…cz Kropki!</h1>
    <p>Sekwencja: 1 â†’ A â†’ 2 â†’ B â†’ ... â†’ 8</p>
    
    <div id="stats">
        <div class="stat-item">
            Czas: <span id="timer" class="stat-value">00:00</span>
        </div>
        <div class="stat-item">
            BÅ‚Ä™dy: <span id="errors" class="stat-value" style="color: var(--color-error);">0</span>
        </div>
    </div>

    <canvas id="gameCanvas" width="600" height="400"></canvas>
    
    <div id="info">Kliknij punkt startowy (1), aby rozpoczÄ…Ä‡!</div>
    <button id="resetButton" onclick="resetGame()">Zacznij nowÄ… grÄ™ (Losuj punkty)</button>

    <script>
        // JavaScript: Logika Gry
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        const timerSpan = document.getElementById('timer');
        const errorsSpan = document.getElementById('errors');
        const resetButton = document.getElementById('resetButton');

        // WewnÄ™trzne wymiary Canvas
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const POINT_RADIUS = 18;
        const FONT_SIZE = '16px';
        const MIN_DISTANCE = 2 * POINT_RADIUS + 30; // Minimalna odlegÅ‚oÅ›Ä‡ miÄ™dzy Å›rodkami punktÃ³w

        // Definicje Etykiet dla 15 punktÃ³w
        const LABELS = ['1', 'A', '2', 'B', '3', 'C', '4', 'D', '5', 'E', '6', 'F', '7', 'G', '8'];
        const POINTS_COUNT = LABELS.length;

        // --- Zmienne Stanu Gry ---
        let timerInterval = null;
        let startTime = null;
        let errorCount = 0;
        let currentPointIndex = 0; 
        let connections = [];      
        let points = []; // Tablica na losowo generowane punkty

        // --- Funkcje Losowania ---

        // Zwraca losowÄ… liczbÄ™ caÅ‚kowitÄ… w zakresie [min, max]
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Generuje losowe punkty, zapewniajÄ…c minimalnÄ… odlegÅ‚oÅ›Ä‡ miÄ™dzy nimi
        function generateRandomPoints(count) {
            const randomPoints = [];
            
            // Ograniczamy zakres losowania, aby punkty nie byÅ‚y zbyt blisko krawÄ™dzi
            const xMin = POINT_RADIUS;
            const xMax = CANVAS_WIDTH - POINT_RADIUS;
            const yMin = POINT_RADIUS;
            const yMax = CANVAS_HEIGHT - POINT_RADIUS;

            for (let i = 0; i < count; i++) {
                let newPoint;
                let isTooClose;

                do {
                    // Losowanie nowych wspÃ³Å‚rzÄ™dnych
                    const x = getRandomInt(xMin, xMax);
                    const y = getRandomInt(yMin, yMax);
                    
                    newPoint = { x: x, y: y, label: LABELS[i] };
                    isTooClose = false;
                    
                    // Sprawdzenie kolizji z istniejÄ…cymi punktami
                    for (const existingPoint of randomPoints) {
                        const distance = Math.sqrt(
                            Math.pow(newPoint.x - existingPoint.x, 2) + 
                            Math.pow(newPoint.y - existingPoint.y, 2)
                        );
                        
                        // JeÅ›li odlegÅ‚oÅ›Ä‡ jest mniejsza niÅ¼ wymagane minimum
                        if (distance < MIN_DISTANCE) {
                            isTooClose = true;
                            break;
                        }
                    }
                } while (isTooClose); // Powtarzaj, jeÅ›li punkt jest za blisko innego

                randomPoints.push(newPoint);
            }
            return randomPoints;
        }

        // --- Funkcje Mierzenia Czasu ---

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            if (startTime) {
                const currentTime = Math.floor((Date.now() - startTime) / 1000);
                timerSpan.textContent = formatTime(currentTime);
            }
        }

        function startTimer() {
            if (timerInterval !== null) return;
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 1000);
            infoDiv.textContent = `Start! Kliknij nastÄ™pny punkt: (${points[currentPointIndex].label})`;
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        // --- Funkcje Rysowania ---

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Rysuj poÅ‚Ä…czenia (linie)
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-primary');
            ctx.lineWidth = 4;
            ctx.beginPath();
            connections.forEach(conn => {
                ctx.moveTo(conn.start.x, conn.start.y);
                ctx.lineTo(conn.end.x, conn.end.y);
            });
            ctx.stroke();
            ctx.closePath();

            // Rysuj punkty i ich etykiety
            points.forEach((point, index) => {
                const isConnected = index < currentPointIndex;

                // Ustaw kolor: Zielony jeÅ›li poÅ‚Ä…czony, Szary jeÅ›li oczekujÄ…cy
                ctx.fillStyle = isConnected 
                    ? getComputedStyle(document.documentElement).getPropertyValue('--color-success') 
                    : getComputedStyle(document.documentElement).getPropertyValue('--color-default');
                
                // Rysuj okrÄ…g
                ctx.beginPath();
                ctx.arc(point.x, point.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                // Rysuj etykietÄ™ (tekst)
                ctx.fillStyle = 'white'; 
                ctx.font = `${FONT_SIZE} Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(point.label, point.x, point.y);
            });
        }

        // Rysowanie finalnej figury po wygranej
        function drawFinalLine() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 
            draw(); 
            
            // Rysujemy finalnÄ… liniÄ™ (grubszÄ… i czerwonÄ…)
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-error'); 
            ctx.lineWidth = 6;
            ctx.beginPath();
            
            points.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            
            ctx.stroke();
        }


        // --- ObsÅ‚uga Interakcji i Reset ---

        function handleInteraction(event) {
            if (event.type === 'touchstart') {
                event.preventDefault();
            }

            if (timerInterval === null && currentPointIndex === points.length) {
                return; // Gra zakoÅ„czona
            }

            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const clickX = clientX - rect.left;
            const clickY = clientY - rect.top;

            // Skalowanie wspÃ³Å‚rzÄ™dnych do wewnÄ™trznego systemu Canvas (600x400)
            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;

            const mouseX = clickX * scaleX;
            const mouseY = clickY * scaleY;

            const expectedPoint = points[currentPointIndex];
            
            // Oblicz odlegÅ‚oÅ›Ä‡
            const distance = Math.sqrt(
                Math.pow(mouseX - expectedPoint.x, 2) + Math.pow(mouseY - expectedPoint.y, 2)
            );

            // SprawdÅº trafienie
            if (distance < POINT_RADIUS) {
                // POPRAWNE KLIKNIÄ˜CIE
                if (currentPointIndex === 0 && timerInterval === null) {
                    startTimer();
                }

                if (currentPointIndex > 0) {
                    const previousPoint = points[currentPointIndex - 1];
                    connections.push({ start: previousPoint, end: expectedPoint });
                }

                currentPointIndex++;

                // Warunek zwyciÄ™stwa
                if (currentPointIndex === points.length) {
                    stopTimer();
                    const finalTime = timerSpan.textContent;
                    
                    infoDiv.innerHTML = `
                        <strong>GRATULACJE! Wszystkie punkty poÅ‚Ä…czone! ðŸ¥³</strong><br>
                        TwÃ³j czas: <span style="color: var(--color-primary);">${finalTime}</span> | 
                        Liczba bÅ‚Ä™dÃ³w: <span style="color: var(--color-error);">${errorCount}</span>
                    `;
                    
                    drawFinalLine();
                } else {
                    infoDiv.textContent = `PoÅ‚Ä…czono! NastÄ™pny: (${points[currentPointIndex].label})`;
                    draw();
                }

            } else if (currentPointIndex > 0 || timerInterval !== null) {
                // NIEPOPRAWNE KLIKNIÄ˜CIE (liczymy bÅ‚Ä™dy tylko po starcie gry)
                errorCount++;
                errorsSpan.textContent = errorCount;
                infoDiv.textContent = `BÅ‚Ä…d! Oczekiwany: (${expectedPoint.label}). BÅ‚Ä™dy: ${errorCount}`;
            }
        }
        
        // Funkcja resetujÄ…ca i rozpoczynajÄ…ca nowÄ… grÄ™
        function resetGame() {
            // Reset stanu
            stopTimer();
            startTime = null;
            errorCount = 0;
            currentPointIndex = 0;
            connections = [];

            // Losowanie nowych punktÃ³w
            points = generateRandomPoints(POINTS_COUNT);

            // Reset wyÅ›wietlania
            timerSpan.textContent = '00:00';
            errorsSpan.textContent = '0';
            infoDiv.textContent = `Kliknij punkt startowy (${points[0].label}), aby rozpoczÄ…Ä‡!`;

            // Przerysowanie
            draw();
            
            // Ponowne wÅ‚Ä…czenie sÅ‚uchaczy (na wypadek, gdyby zostaÅ‚y usuniÄ™te w przyszÅ‚oÅ›ci)
            canvas.removeEventListener('click', handleInteraction);
            canvas.removeEventListener('touchstart', handleInteraction);
            canvas.addEventListener('click', handleInteraction);
            canvas.addEventListener('touchstart', handleInteraction);
        }

        // INICJALIZACJA
        resetGame(); // Uruchomienie gry po raz pierwszy
    </script>

</body>
</html>
