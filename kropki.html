<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychodem - TMT Clinical</title>
    <style>
        /* --- ZMIENNE STYL√ìW --- */
        :root {
            --color-primary: #4f46e5;       
            --color-primary-hover: #4338ca; 
            --color-success: #10b981;       
            --color-default: #94a3b8;       
            --color-error: #ef4444;         
            
            --bg-body: #f1f5f9;             
            --bg-card: #ffffff;             
            --text-main: #1e293b;           
            --text-muted: #64748b;          
            
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --radius: 12px;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background-color 0.3s;
        }

        /* --- TRYB PACJENTA (Pe≈Çny ekran) --- */
        /* Ukrywa wszystko co zbƒôdne, gdy klasa .patient-mode jest aktywna na body */
        body.patient-mode {
            background-color: #f8fafc; /* Czyste t≈Ço dla pacjenta */
            padding: 0;
            justify-content: center;
            overflow: hidden; /* Blokada przewijania */
        }

        body.patient-mode header,
        body.patient-mode #admin-panel,
        body.patient-mode #results-card {
            display: none !important;
        }

        body.patient-mode #game-wrapper {
            box-shadow: none;
            background: transparent;
            padding: 0;
            max-width: none;
        }
        
        body.patient-mode canvas {
            box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1);
            border: 1px solid #e2e8f0;
        }

        /* --- UI GL√ìWNE --- */
        .container {
            max-width: 800px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Karta Administratora */
        .card {
            background-color: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
            padding: 25px;
            text-align: center;
        }

        .logo-wrapper img {
            max-height: 60px;
            width: auto;
            margin-bottom: 10px;
        }

        h1 { margin: 10px 0 5px; font-size: 1.5rem; }
        p.subtitle { color: var(--text-muted); margin: 0 0 20px; font-size: 0.9rem; }

        /* Formularze */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        select, button {
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            font-size: 1rem;
            outline: none;
            cursor: pointer;
        }

        button.primary-btn {
            background-color: var(--color-primary);
            color: white;
            border: none;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(79, 70, 229, 0.3);
            transition: transform 0.1s;
        }
        button.primary-btn:hover { background-color: var(--color-primary-hover); }
        button.primary-btn:active { transform: translateY(1px); }

        /* P≈Ç√≥tno Gry */
        #game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: white;
            border-radius: var(--radius);
            cursor: crosshair;
            touch-action: none;
            /* Domy≈õlnie lekki cie≈Ñ w trybie admina */
            box-shadow: var(--shadow-md);
        }

        /* --- WYNIKI I NORMY --- */
        #results-card {
            display: none; /* Ukryte domy≈õlnie */
            text-align: left;
            animation: fadeIn 0.5s;
            border-left: 5px solid var(--color-primary);
        }

        .result-header {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .norm-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        .norm-table th, .norm-table td {
            padding: 10px;
            border-bottom: 1px solid #e2e8f0;
            text-align: left;
        }
        
        .norm-table th { background-color: #f8fafc; color: var(--text-muted); }
        
        .highlight-row { background-color: #ecfdf5; font-weight: bold; } /* Zielony pasek dla wyniku pacjenta */
        .highlight-row-bad { background-color: #fef2f2; font-weight: bold; } /* Czerwony pasek */

        .btn-restart {
            margin-top: 20px;
            background-color: var(--text-main);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
        }

        /* Komunikaty w grze */
        #game-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: var(--shadow-md);
            pointer-events: none;
            font-weight: 600;
            color: var(--color-primary);
            opacity: 0;
            transition: opacity 0.3s;
        }
        body.patient-mode #game-info { opacity: 1; } /* Poka≈º info tylko w trybie gry */

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div class="container">
        
        <header>
            <div class="logo-wrapper">
                <a href="#"><img src="logo.png" alt="Logo"></a>
            </div>
            <h1>Test ≈ÅƒÖczenia Punkt√≥w (TMT)</h1>
            <p class="subtitle">Wybierz wersjƒô testu i przygotuj pacjenta.</p>
        </header>

        <div id="admin-panel" class="card">
            <div class="controls">
                <select id="levelSelect">
                    <option value="A">Wersja A (Tylko liczby: 1-25)</option>
                    <option value="B">Wersja B (Naprzemiennie: 1-A...)</option>
                </select>
                <button class="primary-btn" onclick="startTest()">Rozpocznij Test (Pe≈Çny ekran)</button>
            </div>
            <p style="font-size: 0.85rem; color: var(--text-muted);">
                Po klikniƒôciu "Rozpocznij", zegar i interfejs zostanƒÖ ukryte. <br>
                Zegar startuje po klikniƒôciu pierwszego punktu. Test ko≈Ñczy siƒô po po≈ÇƒÖczeniu ostatniego.
            </p>
        </div>

        <div id="results-card" class="card">
            <div class="result-header">
                <span>Wynik Pacjenta</span>
                <span id="final-time-display" style="color: var(--color-primary); font-size: 1.4rem;">00:00</span>
            </div>
            <div id="interpretation-text"></div>
            
            <table class="norm-table">
                <thead>
                    <tr>
                        <th>Interpretacja</th>
                        <th>Wersja A (Czas)</th>
                        <th>Wersja B (Czas)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr id="row-norm">
                        <td>üü¢ Norma (Zdrowi doro≈õli)</td>
                        <td>&lt; 40 sek.</td>
                        <td>&lt; 60 sek.</td>
                    </tr>
                    <tr id="row-low">
                        <td>üü† Wynik obni≈ºony / Do obserwacji</td>
                        <td>41 - 90 sek.</td>
                        <td>61 - 180 sek.</td>
                    </tr>
                    <tr id="row-clinical">
                        <td>üî¥ Wynik kliniczny (Mo≈ºliwe zaburzenia)</td>
                        <td>&gt; 90 sek.</td>
                        <td>&gt; 180 sek.</td>
                    </tr>
                </tbody>
            </table>

            <div style="margin-top: 15px; font-size: 0.85rem; color: var(--text-muted); text-align: left;">
                <em>*Normy orientacyjne wg Talarowska et al. (2012). Wynik wymaga interpretacji psychologa. Liczba b≈Çƒôd√≥w w te≈õcie: <span id="error-display-count">0</span>.</em>
            </div>

            <button class="btn-restart" onclick="location.reload()">Resetuj / Nowy Pacjent</button>
        </div>

        <div id="game-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="game-info">Po≈ÇƒÖcz punkty w kolejno≈õci</div>
        </div>

    </div>

    <script>
        // --- KONFIGURACJA ---
        // Zdefiniowane dok≈Çadnie wg standardu klinicznego
        const LEVELS = {
            A: {
                type: 'A',
                count: 25,
                labels: Array.from({ length: 25 }, (_, i) => (i + 1).toString()), // 1..25
                desc: "1 ‚Üí 2 ‚Üí 3 ... ‚Üí 25"
            },
            B: {
                type: 'B',
                count: 25,
                // 13 cyfr (1-13) i 12 liter (A-L). Razem 25.
                labels: ['1', 'A', '2', 'B', '3', 'C', '4', 'D', '5', 'E', '6', 'F', '7', 'G', '8', 'H', '9', 'I', '10', 'J', '11', 'K', '12', 'L', '13'],
                desc: "1 ‚Üí A ‚Üí 2 ‚Üí B ... ‚Üí 13"
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameInfo = document.getElementById('game-info');
        
        // Zmienne stanu
        let currentLevel = null;
        let points = [];
        let connections = [];
        let currentPointIndex = 0;
        let startTime = null;
        let endTime = null;
        let errorCount = 0;
        let isRunning = false; // Czy test trwa (tryb pacjenta)

        // Sta≈Çe graficzne
        const POINT_RADIUS = 18;
        const MIN_DISTANCE = 55; // Minimalny odstƒôp miƒôdzy punktami
        
        // --- FUNKCJE LOGIKI GRY ---

        function startTest() {
            // Pobranie wyboru
            const type = document.getElementById('levelSelect').value;
            currentLevel = LEVELS[type];

            // Reset zmiennych
            points = generatePoints(currentLevel.labels);
            connections = [];
            currentPointIndex = 0;
            errorCount = 0;
            startTime = null; // Czas startuje dopiero po 1 klikniƒôciu
            endTime = null;
            
            // Wej≈õcie w tryb pacjenta (ukrycie UI)
            document.body.classList.add('patient-mode');
            
            // Reset widoku wynik√≥w (je≈õli by≈Ç widoczny)
            document.getElementById('results-card').style.display = 'none';
            document.getElementById('admin-panel').style.display = 'none'; // Tymczasowo ukryj, klasa css i tak to robi ale dla pewno≈õci

            // Komunikat startowy
            gameInfo.textContent = `Kliknij start: (${points[0].label})`;
            isRunning = true;
            
            draw();
        }

        function endTest() {
            isRunning = false;
            endTime = Date.now();
            const totalTimeSeconds = (endTime - startTime) / 1000;

            // Wyj≈õcie z trybu pacjenta
            document.body.classList.remove('patient-mode');
            document.getElementById('admin-panel').style.display = 'block';

            // Poka≈º wyniki
            showResults(totalTimeSeconds, errorCount, currentLevel.type);
            
            // Rysowanie ko≈Ñcowe (linia powrotna lub zamro≈ºenie stanu)
            draw();
        }

        function showResults(seconds, errors, type) {
            const resultsCard = document.getElementById('results-card');
            const timeDisplay = document.getElementById('final-time-display');
            const errorDisplay = document.getElementById('error-display-count');
            const interpText = document.getElementById('interpretation-text');
            
            // Formatowanie czasu
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            timeDisplay.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            errorDisplay.textContent = errors;

            // Logika Norm (Talarowska et al.)
            let status = 'norm'; // norm, low, clinical
            
            if (type === 'A') {
                if (seconds <= 40) status = 'norm';
                else if (seconds <= 90) status = 'low';
                else status = 'clinical';
            } else { // Type B
                if (seconds <= 60) status = 'norm';
                else if (seconds <= 180) status = 'low';
                else status = 'clinical';
            }

            // Pod≈õwietlanie tabeli i tekst
            document.querySelectorAll('.norm-table tr').forEach(tr => {
                tr.classList.remove('highlight-row', 'highlight-row-bad');
            });

            if (status === 'norm') {
                document.getElementById('row-norm').classList.add('highlight-row');
                interpText.innerHTML = `<span style="color:var(--color-success); font-weight:bold;">Wynik w normie.</span>`;
            } else if (status === 'low') {
                document.getElementById('row-low').classList.add('highlight-row-bad');
                interpText.innerHTML = `<span style="color:orange; font-weight:bold;">Wynik poni≈ºej oczekiwa≈Ñ (sugerowana obserwacja).</span>`;
            } else {
                document.getElementById('row-clinical').classList.add('highlight-row-bad');
                interpText.innerHTML = `<span style="color:var(--color-error); font-weight:bold;">Wynik kliniczny (istotne spowolnienie).</span>`;
            }

            resultsCard.style.display = 'block';
            resultsCard.scrollIntoView({ behavior: 'smooth' });
        }

        // --- GENEROWANIE PUNKT√ìW (Bez nak≈Çadania siƒô) ---
        function generatePoints(labels) {
            const newPoints = [];
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;

            for (let label of labels) {
                let point, valid;
                let attempts = 0;
                do {
                    valid = true;
                    point = {
                        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,
                        y: Math.floor(Math.random() * (height - 2 * padding)) + padding,
                        label: label
                    };

                    // Sprawd≈∫ kolizje
                    for (let existing of newPoints) {
                        const dist = Math.hypot(point.x - existing.x, point.y - existing.y);
                        if (dist < MIN_DISTANCE) {
                            valid = false;
                            break;
                        }
                    }
                    attempts++;
                    // Zabezpieczenie przed niesko≈ÑczonƒÖ pƒôtlƒÖ (rzadkie)
                    if (attempts > 500) break; 
                } while (!valid);
                newPoints.push(point);
            }
            return newPoints;
        }

        // --- RYSOWANIE ---
        function draw() {
            // Czy≈õcimy
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Linie
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();
            ctx.lineWidth = 3;
            ctx.beginPath();
            connections.forEach(conn => {
                ctx.moveTo(conn.start.x, conn.start.y);
                ctx.lineTo(conn.end.x, conn.end.y);
            });
            ctx.stroke();

            // Punkty
            points.forEach((p, idx) => {
                const isConnected = idx < currentPointIndex;
                const isNext = idx === currentPointIndex;

                ctx.beginPath();
                ctx.arc(p.x, p.y, POINT_RADIUS, 0, Math.PI * 2);
                
                // Styl wype≈Çnienia
                if (isConnected) ctx.fillStyle = '#10b981'; // Zielony
                else ctx.fillStyle = '#e2e8f0'; // Szary (nieaktywny)
                
                // Je≈õli to nastƒôpny punkt i gra trwa - lekko wyr√≥≈ºnij obw√≥dkƒÖ (opcjonalne, subtelne)
                if (isNext && isRunning) {
                    ctx.strokeStyle = '#4f46e5';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.fill();

                // Tekst
                ctx.fillStyle = isConnected ? 'white' : '#1e293b';
                ctx.font = "bold 16px Arial";
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.label, p.x, p.y);
            });
        }

        // --- OBS≈ÅUGA KLIKNIƒòƒÜ ---
        function handleClick(e) {
            if (!isRunning) return; // Klikniƒôcia dzia≈ÇajƒÖ tylko po naci≈õniƒôciu Start

            const rect = canvas.getBoundingClientRect();
            // Skalowanie na wypadek gdyby canvas by≈Ç przeskalowany CSSem
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Sprawd≈∫ czy klikniƒôto w OCZEKIWANY punkt
            const target = points[currentPointIndex];
            const dist = Math.hypot(x - target.x, y - target.y);

            if (dist < POINT_RADIUS + 10) { // +10 marginesu b≈Çƒôdu dla palca/myszy
                // Poprawne klikniƒôcie
                if (currentPointIndex === 0) {
                    startTime = Date.now(); // Start czasu dopiero teraz!
                    gameInfo.textContent = `Szukaj: ${points[1].label}`;
                } else {
                    connections.push({ start: points[currentPointIndex - 1], end: target });
                    if (currentPointIndex < points.length - 1) {
                         gameInfo.textContent = `Dobrze! Nastƒôpny: ${points[currentPointIndex + 1].label}`;
                    }
                }

                currentPointIndex++;
                draw();

                // Czy koniec?
                if (currentPointIndex >= points.length) {
                    endTest();
                }
            } else {
                // Sprawd≈∫ czy klikniƒôto w JAKIKOLWIEK INNY (B≈ÅƒòDNY) punkt
                // (Tylko je≈õli zegar ju≈º ruszy≈Ç)
                if (startTime) {
                    let clickedWrong = false;
                    for (let i = 0; i < points.length; i++) {
                        if (i === currentPointIndex) continue; // Pomi≈Ñ poprawny
                        if (i < currentPointIndex) continue;   // Pomi≈Ñ ju≈º po≈ÇƒÖczone
                        
                        const d = Math.hypot(x - points[i].x, y - points[i].y);
                        if (d < POINT_RADIUS + 10) {
                            clickedWrong = true;
                            break;
                        }
                    }
                    
                    if (clickedWrong) {
                        errorCount++;
                        // Delikatny flash na czerwono (opcjonalnie)
                        const originalBg = canvas.style.backgroundColor;
                        canvas.style.backgroundColor = '#fef2f2';
                        setTimeout(() => canvas.style.backgroundColor = 'white', 200);
                    }
                }
            }
        }

        // Nas≈Çuchuj mysz i dotyk
        canvas.addEventListener('mousedown', handleClick);
        // Zapobieganie podw√≥jnemu wywo≈Çaniu na touch devices jest tu uproszczone, 
        // w prostym modelu mousedown wystarczy, chyba ≈ºe potrzebny multitouch.
        
        // Pierwsze rysowanie (puste)
        ctx.font = "20px Arial";
        ctx.fillStyle = "#64748b";
        ctx.textAlign = "center";
        ctx.fillText("Wybierz wersjƒô i kliknij Start", canvas.width/2, canvas.height/2);

    </script>
</body>
</html>
