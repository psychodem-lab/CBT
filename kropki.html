<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychodem - Test Uwagi</title>
    <style>
        /* --- NOWOCZESNA PALETA KOLOR√ìW I ZMIENNE --- */
        :root {
            /* Nowoczesne odcienie (Indigo, Slate, Emerald, Rose) */
            --color-primary: #4f46e5;       /* G≈Ç√≥wny akcent (Indigo) */
            --color-primary-hover: #4338ca; 
            --color-success: #10b981;       /* Sukces (Emerald) */
            --color-default: #94a3b8;       /* Punkty nieaktywne (Slate) */
            --color-error: #ef4444;         /* B≈ÇƒÖd (Rose) */
            
            --bg-body: #f8fafc;             /* Bardzo jasne t≈Ço strony */
            --bg-card: #ffffff;             /* T≈Ço kontenera gry */
            --text-main: #1e293b;           /* Ciemny grafit dla tekstu */
            --text-muted: #64748b;          /* Szary dla opis√≥w */
            
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --radius: 12px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- LAYOUT KARTY --- */
        .game-container {
            background-color: var(--bg-card);
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
            max-width: 800px;
            width: 100%;
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- NAG≈Å√ìWEK I LOGO --- */
        header {
            margin-bottom: 20px;
            text-align: center;
        }

        .logo-wrapper img {
            max-height: 80px;
            width: auto;
            display: block;
            margin: 0 auto;
        }

        h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin: 15px 0 5px 0;
            color: var(--text-main);
            letter-spacing: -0.025em;
        }

        #sequenceInfo {
            color: var(--text-muted);
            font-size: 0.95rem;
            margin-top: 0;
            margin-bottom: 25px;
        }

        /* --- KONTROLKI (INPUTY I BUTTONY) --- */
        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 25px;
            width: 100%;
        }

        select, button {
            font-family: inherit;
            font-size: 0.95rem;
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            outline: none;
            transition: all 0.2s ease;
        }

        select {
            background-color: #fff;
            color: var(--text-main);
            cursor: pointer;
            min-width: 200px;
        }

        select:hover, select:focus {
            border-color: var(--color-primary);
        }

        button#resetButton {
            background-color: var(--color-primary);
            color: white;
            border: none;
            font-weight: 600;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }

        button#resetButton:hover {
            background-color: var(--color-primary-hover);
            transform: translateY(-1px);
        }

        button#resetButton:active {
            transform: translateY(0);
        }

        /* Checkbox Container */
        #hintToggleContainer {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--text-muted);
            background: #f1f5f9;
            padding: 8px 12px;
            border-radius: 8px;
        }

        input[type="checkbox"] {
            accent-color: var(--color-primary);
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* --- STATYSTYKI --- */
        #stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px;
            margin-bottom: 20px;
            padding: 15px 25px;
            background-color: #f8fafc; /* Lekko szare t≈Ço dla statystyk */
            border-radius: var(--radius);
            border: 1px solid #e2e8f0;
        }

        .stat-item {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-muted);
            display: flex;
            gap: 8px;
        }

        .stat-value {
            font-family: 'Courier New', monospace; /* Monospace dla cyfr */
            font-weight: 700;
            font-size: 1.1rem;
        }

        #timer { color: var(--color-primary); }
        #errors { color: var(--color-error); }

        /* --- P≈Å√ìTNO (CANVAS) --- */
        canvas {
            border-radius: var(--radius);
            background-color: white;
            box-shadow: var(--shadow-md); /* Cie≈Ñ zamiast obramowania */
            border: 1px solid #e2e8f0;    /* Bardzo delikatna ramka */
            cursor: crosshair;
            touch-action: none;
            max-width: 100%;
            height: auto;
            margin-bottom: 20px;
        }

        /* --- KOMUNIKATY --- */
        #info {
            width: 100%;
            max-width: 600px;
            padding: 12px 20px;
            text-align: center;
            font-weight: 500;
            color: var(--text-main);
            background-color: #fff;
            border-left: 4px solid var(--color-primary);
            border-radius: 4px;
            box-shadow: var(--shadow-sm);
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        /* Klasa dodawana przez JS do ukrywania */
        .hidden-info {
            visibility: hidden;
            opacity: 0;
        }

        /* RWD */
        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
            }
            #controls {
                flex-direction: column;
                align-items: stretch;
            }
            #stats {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <header>
            <div class="logo-wrapper">
                <a href="index.html" title="Powr√≥t do strony g≈Ç√≥wnej">
                    <img src="logo.png" alt="Logo Psychodem">
                </a>
            </div>
            <h1>Po≈ÇƒÖcz Kropki</h1>
            <p id="sequenceInfo">Aktualna sekwencja: 1 ‚Üí 2 ‚Üí 3 ‚Üí ...</p>
        </header>
        
        <div id="controls">
            <select id="levelSelect" onchange="resetGame()">
                <option value="easy">Poziom: ≈Åatwy (1 ‚Üí 20)</option>
                <option value="medium" selected>Poziom: ≈öredni (1, A, 2, B...)</option>
                <option value="hard">Poziom: Trudny (d≈Çugi)</option>
            </select>
            
            <button id="resetButton" onclick="resetGame()">Nowa Gra (Losuj)</button>

            <div id="hintToggleContainer">
                <input type="checkbox" id="hintToggle" onchange="toggleHints()">
                <label for="hintToggle">Ukryj podpowiedzi</label>
            </div>
        </div>

        <div id="stats">
            <div class="stat-item">
                <span>Czas:</span>
                <span id="timer" class="stat-value">00:00</span>
            </div>
            <div class="stat-item">
                <span>B≈Çƒôdy:</span>
                <span id="errors" class="stat-value">0</span>
            </div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <div id="info">Wybierz poziom i kliknij (1), aby rozpoczƒÖƒá!</div>
    </div>

    <script>
        // JavaScript: Logika Gry
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        const timerSpan = document.getElementById('timer');
        const errorsSpan = document.getElementById('errors');
        const levelSelect = document.getElementById('levelSelect');
        const sequenceInfo = document.getElementById('sequenceInfo');
        const hintToggle = document.getElementById('hintToggle');

        // Wewnƒôtrzne wymiary Canvas
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const POINT_RADIUS = 18;
        const FONT_SIZE = '16px';
        const MIN_DISTANCE = 2 * POINT_RADIUS + 30;

        // --- DEFINICJE POZIOM√ìW ---
        const LEVELS = {
            easy: {
                count: 20,
                labels: Array.from({ length: 20 }, (_, i) => (i + 1).toString()),
                desc: "1 ‚Üí 2 ‚Üí 3 ‚Üí ... ‚Üí 20"
            },
            medium: {
                count: 15,
                labels: ['1', 'A', '2', 'B', '3', 'C', '4', 'D', '5', 'E', '6', 'F', '7', 'G', '8'],
                desc: "1 ‚Üí A ‚Üí 2 ‚Üí B ‚Üí ... ‚Üí 8"
            },
            hard: {
                count: 25,
                labels: [
                    '1', 'A', '2', 'B', '3', 'C', '4', 'D', '5', 'E', '6', 'F', '7', 'G', '8', 
                    'H', '9', 'I', '10', 'J', '11', 'K', '12', 'L', '13'
                ],
                desc: "1 ‚Üí A ‚Üí 2 ‚Üí B ‚Üí ... ‚Üí 13"
            }
        };

        // --- Zmienne Stanu Gry ---
        let timerInterval = null;
        let startTime = null;
        let errorCount = 0;
        let currentPointIndex = 0; 
        let connections = [];      
        let points = [];
        let currentLevel = LEVELS['medium'];

        // --- Funkcje Ukrywania Podpowiedzi ---

        function toggleHints() {
            if (hintToggle.checked) {
                // Ukryj podpowiedzi
                infoDiv.classList.add('hidden-info');
            } else {
                // Poka≈º podpowiedzi
                infoDiv.classList.remove('hidden-info');
                // Je≈õli gra siƒô rozpoczƒô≈Ça, od≈õwie≈º komunikat
                if (currentPointIndex > 0 && currentPointIndex < points.length && timerInterval !== null) {
                    infoDiv.textContent = `Nastƒôpny punkt: (${points[currentPointIndex].label})`;
                }
            }
        }

        function updateInfoDisplay(message, isEndGame = false) {
            if (isEndGame || !hintToggle.checked) {
                // Zawsze pokazuj ko≈Ñcowy komunikat lub je≈õli podpowiedzi sƒÖ w≈ÇƒÖczone
                infoDiv.innerHTML = message;
                infoDiv.classList.remove('hidden-info');
            } else {
                // Je≈õli ukrywamy podpowiedzi, tylko wyczy≈õƒá/ukryj komunikat
                infoDiv.classList.add('hidden-info');
            }
        }

        // --- Funkcje Losowania ---

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function generateRandomPoints() {
            const randomPoints = [];
            const labels = currentLevel.labels;
            
            const xMin = POINT_RADIUS;
            const xMax = CANVAS_WIDTH - POINT_RADIUS;
            const yMin = POINT_RADIUS;
            const yMax = CANVAS_HEIGHT - POINT_RADIUS;

            for (let i = 0; i < labels.length; i++) {
                let newPoint;
                let isTooClose;

                do {
                    const x = getRandomInt(xMin, xMax);
                    const y = getRandomInt(yMin, yMax);
                    
                    newPoint = { x: x, y: y, label: labels[i] };
                    isTooClose = false;
                    for (const existingPoint of randomPoints) {
                        const distance = Math.sqrt(
                            Math.pow(newPoint.x - existingPoint.x, 2) + 
                            Math.pow(newPoint.y - existingPoint.y, 2)
                        );
                        if (distance < MIN_DISTANCE) {
                            isTooClose = true;
                            break;
                        }
                    }
                } while (isTooClose);
                randomPoints.push(newPoint);
            }
            return randomPoints;
        }

        // --- Funkcje Czasu ---
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        function updateTimerDisplay() {
            if (startTime) {
                const currentTime = Math.floor((Date.now() - startTime) / 1000);
                timerSpan.textContent = formatTime(currentTime);
            }
        }
        function startTimer() {
            if (timerInterval !== null) return;
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 1000);
            updateInfoDisplay(`Start! Kliknij nastƒôpny punkt: (${points[currentPointIndex].label})`);
        }
        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        // --- Funkcje Rysowania ---
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            // Zmieniono tylko ≈∫r√≥d≈Ço koloru (teraz pobiera zaktualizowane zmienne CSS)
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();
            ctx.lineWidth = 4;
            ctx.beginPath();
            connections.forEach(conn => {
                ctx.moveTo(conn.start.x, conn.start.y);
                ctx.lineTo(conn.end.x, conn.end.y);
            });
            ctx.stroke();
            ctx.closePath();

            points.forEach((point, index) => {
                const isConnected = index < currentPointIndex;

                ctx.fillStyle = isConnected 
                    ? getComputedStyle(document.documentElement).getPropertyValue('--color-success').trim()
                    : getComputedStyle(document.documentElement).getPropertyValue('--color-default').trim();
            
                ctx.beginPath();
                ctx.arc(point.x, point.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white'; 
                ctx.font = `bold ${FONT_SIZE} Arial`; // Dodano 'bold' dla lepszej czytelno≈õci na nowych kolorach
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(point.label, point.x, point.y);
            });
        }

        function drawFinalLine() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            draw(); 
            
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-error').trim(); 
            ctx.lineWidth = 6;
            ctx.beginPath();
            
            points.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            ctx.stroke();
        }

        // --- Obs≈Çuga Interakcji ---

        function handleInteraction(event) {
            if (event.type === 'touchstart') {
                event.preventDefault();
            }

            if (timerInterval === null && currentPointIndex === points.length) {
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            const clickX = clientX - rect.left;
            const clickY = clientY - rect.top;

            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;

            const mouseX = clickX * scaleX;
            const mouseY = clickY * scaleY;
            const expectedPoint = points[currentPointIndex];
            
            // 1. Sprawd≈∫, czy klikniƒôto w oczekiwany punkt
            const distanceToExpected = Math.sqrt(
                Math.pow(mouseX - expectedPoint.x, 2) + Math.pow(mouseY - expectedPoint.y, 2)
            );

            if (distanceToExpected < POINT_RADIUS) {
                // POPRAWNE KLIKNIƒòCIE
                if (currentPointIndex === 0 && timerInterval === null) {
                    startTimer();
                }

                if (currentPointIndex > 0) {
                    const previousPoint = points[currentPointIndex - 1];
                    connections.push({ start: previousPoint, end: expectedPoint });
                }

                currentPointIndex++;
                if (currentPointIndex === points.length) {
                    stopTimer();
                    const finalTime = timerSpan.textContent;
                    
                    const finalMessage = `
                        <strong style="color:var(--color-success)">GRATULACJE! Wszystkie punkty po≈ÇƒÖczone! ü•≥</strong><br>
                        Tw√≥j czas: <span style="color: var(--color-primary);">${finalTime}</span> |
                        Liczba b≈Çƒôd√≥w: <span style="color: var(--color-error);">${errorCount}</span>
                    `;
                    updateInfoDisplay(finalMessage, true); // Zawsze pokazuj na koniec
                    
                    drawFinalLine();
                } else {
                    updateInfoDisplay(`Po≈ÇƒÖczono! Nastƒôpny: (${points[currentPointIndex].label})`);
                    draw();
                }
                return;
            } 
            
            // 2. Je≈õli nie klikniƒôto poprawnie, sprawd≈∫, czy klikniƒôto jakikolwiek inny punkt
            let clickedWrongPoint = false;
            if (currentPointIndex > 0 || timerInterval !== null) { 
                for(let i = 0; i < points.length; i++) {
                    const currentPoint = points[i];
                    // Pomijamy ju≈º po≈ÇƒÖczone punkty i oczekiwany punkt
                    if (i < currentPointIndex) continue;
                    if (i === currentPointIndex) continue;

                    const distance = Math.sqrt(
                        Math.pow(mouseX - currentPoint.x, 2) + Math.pow(mouseY - currentPoint.y, 2)
                    );
                    if (distance < POINT_RADIUS) {
                        clickedWrongPoint = true;
                        break;
                    }
                }
            }

            // 3. Je≈õli klikniƒôto w Z≈ÅY SYMBOL - nalicz b≈ÇƒÖd
            if (clickedWrongPoint) {
                errorCount++;
                errorsSpan.textContent = errorCount;
                const errorMessage = `B≈ÅƒÑD! Klikniƒôto z≈Çy symbol. Oczekiwany: (${expectedPoint.label}). B≈Çƒôdy: ${errorCount}`;
                updateInfoDisplay(errorMessage);
            } 
            // 4. W przeciwnym razie (klikniƒôto puste t≈Ço) - zignoruj
            else if (currentPointIndex > 0 || timerInterval !== null) {
                 const emptyMessage = `Puste t≈Ço. Kliknij symbol (${expectedPoint.label})`;
                 updateInfoDisplay(emptyMessage);
            }
        }
        
        // --- Funkcja Reset i Konfiguracja Gry ---
        function resetGame() {
            // Konfiguracja nowego poziomu
            const selectedLevelKey = levelSelect.value;
            currentLevel = LEVELS[selectedLevelKey];

            // Reset stanu
            stopTimer();
            startTime = null;
            errorCount = 0;
            currentPointIndex = 0;
            connections = [];
            // Generowanie nowych punkt√≥w dla wybranego poziomu
            points = generateRandomPoints();
            // Aktualizacja informacji o sekwencji
            sequenceInfo.textContent = `Aktualna sekwencja: ${currentLevel.desc}`;
            // Reset wy≈õwietlania
            timerSpan.textContent = '00:00';
            errorsSpan.textContent = '0';
            // Ustawienie poczƒÖtkowego komunikatu
            const startMessage = `Kliknij punkt startowy (${points[0].label}), aby rozpoczƒÖƒá!`;
            updateInfoDisplay(startMessage, true); // Zawsze pokazuj poczƒÖtkowy komunikat
            toggleHints(); // Stosuje ukrycie/pokazanie po resecie

            // Przerysowanie
            draw();
            // Ponowne w≈ÇƒÖczenie s≈Çuchaczy
            canvas.removeEventListener('click', handleInteraction);
            canvas.removeEventListener('touchstart', handleInteraction);
            canvas.addEventListener('click', handleInteraction);
            canvas.addEventListener('touchstart', handleInteraction);
        }

        // INICJALIZACJA GRY
        resetGame();
    </script>

</body>
</html>
